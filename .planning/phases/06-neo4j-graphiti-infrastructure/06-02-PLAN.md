---
phase: 06-neo4j-graphiti-infrastructure
plan: 02
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - src/pam/api/main.py
  - src/pam/api/deps.py
  - src/pam/api/routes/graph.py
  - tests/test_api/test_graph_status.py
  - tests/test_graph/__init__.py
  - tests/test_graph/test_entity_types.py
  - tests/test_graph/test_service.py
autonomous: true
requirements: [INFRA-03, INFRA-04]

must_haves:
  truths:
    - "GraphitiService is created during FastAPI lifespan startup and stored on app.state.graph_service"
    - "GraphitiService.close() is called during shutdown"
    - "get_graph_service() dependency returns the GraphitiService from app.state using cast()"
    - "Neo4j status appears in /api/health endpoint alongside postgres and elasticsearch"
    - "GET /api/graph/status returns Neo4j connection status, entity counts, and last sync time"
  artifacts:
    - path: "src/pam/api/main.py"
      provides: "GraphitiService creation in lifespan, Neo4j health check, graph router inclusion"
      contains: "graph_service"
    - path: "src/pam/api/deps.py"
      provides: "get_graph_service() dependency with cast() pattern"
      contains: "get_graph_service"
    - path: "src/pam/api/routes/graph.py"
      provides: "GET /api/graph/status endpoint"
      contains: "graph_status"
    - path: "tests/test_graph/test_entity_types.py"
      provides: "Tests for entity type taxonomy correctness"
      contains: "test_entity_types"
    - path: "tests/test_graph/test_service.py"
      provides: "Tests for GraphitiService class"
      contains: "test_graphiti_service"
    - path: "tests/test_api/test_graph_status.py"
      provides: "Test for graph status endpoint"
      contains: "test_graph_status"
  key_links:
    - from: "src/pam/api/main.py"
      to: "src/pam/graph/service.py"
      via: "GraphitiService.create() in lifespan, graph_service.close() in shutdown"
      pattern: "GraphitiService\\.create|graph_service\\.close"
    - from: "src/pam/api/deps.py"
      to: "src/pam/graph/service.py"
      via: "cast(GraphitiService, request.app.state.graph_service)"
      pattern: "cast.*GraphitiService.*graph_service"
    - from: "src/pam/api/routes/graph.py"
      to: "src/pam/api/deps.py"
      via: "Depends(get_graph_service)"
      pattern: "Depends.*get_graph_service"
    - from: "src/pam/api/main.py"
      to: "src/pam/api/routes/graph.py"
      via: "app.include_router(graph.router)"
      pattern: "include_router.*graph"
---

<objective>
Wire GraphitiService into FastAPI lifecycle (lifespan creation, app.state storage, shutdown cleanup), add dependency injection function, add Neo4j to health check, create the graph status endpoint, and add tests.

Purpose: Makes the graph service available to all route handlers via dependency injection, following the exact same pattern used by ES, Redis, and other services. Adds the dedicated graph status endpoint and Neo4j health monitoring.
Output: GraphitiService integrated into app lifecycle, graph status API live, tests passing.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/06-neo4j-graphiti-infrastructure/06-CONTEXT.md
@.planning/phases/06-neo4j-graphiti-infrastructure/06-RESEARCH.md
@.planning/phases/06-neo4j-graphiti-infrastructure/06-01-SUMMARY.md
@src/pam/api/main.py
@src/pam/api/deps.py
@src/pam/graph/service.py
@src/pam/graph/entity_types.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Lifespan + deps.py + health check + graph status endpoint</name>
  <files>
    src/pam/api/main.py
    src/pam/api/deps.py
    src/pam/api/routes/graph.py
  </files>
  <action>
1. Update `src/pam/api/main.py` lifespan():
   - After the DuckDB block and before `yield`, add a `# --- Graphiti / Neo4j ---` section
   - Import `GraphitiService` from `pam.graph.service`
   - Create the service: `graph_service = await GraphitiService.create(neo4j_uri=settings.neo4j_uri, neo4j_user=settings.neo4j_user, neo4j_password=settings.neo4j_password, anthropic_api_key=settings.anthropic_api_key, openai_api_key=settings.openai_api_key, anthropic_model=settings.graphiti_model, embedding_model=settings.graphiti_embedding_model)`
   - Store: `app.state.graph_service = graph_service`
   - In the shutdown section (after `yield`), add `await graph_service.close()` BEFORE `await engine.dispose()` (close graph first, then DB engine last)

2. Update the `/api/health` endpoint in main.py to add Neo4j check:
   - After the Redis check block, add a `# Check Neo4j` block
   - Get graph_service from `request.app.state` using `getattr(request.app.state, "graph_service", None)`
   - If graph_service exists, use `graph_service.client.driver` to open an async session and run `RETURN 1`
   - Set `services["neo4j"] = "up"` on success, `"down"` on exception
   - If no graph_service, set `services["neo4j"] = "down"`
   - Follow the exact same pattern as the Redis health check (try/except with logger.warning)

3. Add graph router to `create_app()`:
   - Import: `from pam.api.routes import graph` (add to existing import line)
   - Add: `app.include_router(graph.router, prefix="/api", tags=["graph"])` after the admin router inclusion

4. Update `src/pam/api/deps.py`:
   - Add import for `GraphitiService` from `pam.graph.service`
   - Add `get_graph_service(request: Request) -> GraphitiService:` function using `cast(GraphitiService, request.app.state.graph_service)` -- matches the pattern of `get_es_client`, `get_search_service`, etc.

5. Create `src/pam/api/routes/graph.py`:
   - APIRouter with `router = APIRouter()`
   - `GET /graph/status` endpoint (will be mounted at `/api/graph/status` via prefix)
   - Depends on `get_graph_service` from deps.py
   - Queries Neo4j for:
     a. Entity counts by label: `MATCH (n:Entity) RETURN labels(n) AS labels, count(n) AS count`
     b. Last sync time: `MATCH (e:Episodic) RETURN max(e.created_at) AS last_sync`
   - Returns JSON: `{"status": "connected", "entity_counts": {...}, "total_entities": N, "last_sync_time": "..." | null}`
   - On exception: returns `{"status": "disconnected", "error": str(e)}` (still 200 -- status field indicates state)
   - Use structlog for logging
   - Add proper docstrings

Ensure all modified/new files pass `ruff check`. Follow existing import ordering conventions.
  </action>
  <verify>
- `ruff check src/pam/api/main.py src/pam/api/deps.py src/pam/api/routes/graph.py` passes
- `python -c "from pam.api.deps import get_graph_service; print('OK')"` prints OK
- `python -c "from pam.api.routes.graph import router; print(router.routes)"` shows graph/status route
  </verify>
  <done>GraphitiService is created in lifespan, stored on app.state, accessible via get_graph_service() dependency. Neo4j appears in /api/health. GET /api/graph/status returns graph database metrics.</done>
</task>

<task type="auto">
  <name>Task 2: Tests for graph module + graph status endpoint</name>
  <files>
    tests/test_graph/__init__.py
    tests/test_graph/test_entity_types.py
    tests/test_graph/test_service.py
    tests/test_api/test_graph_status.py
  </files>
  <action>
1. Create `tests/test_graph/__init__.py` (empty).

2. Create `tests/test_graph/test_entity_types.py`:
   - Test `ENTITY_TYPES` has exactly 7 entries
   - Test all 7 expected type names exist: Person, Team, Project, Technology, Process, Concept, Asset
   - Test no model uses Graphiti protected field names (uuid, name, group_id, labels, created_at, summary, attributes, name_embedding)
   - Test each model can be instantiated with no arguments (all fields Optional)
   - Test each model can be instantiated with all fields populated
   - Test ENTITY_TYPES values are all subclasses of BaseModel

3. Create `tests/test_graph/test_service.py`:
   - Test GraphitiService.__init__ stores client
   - Test GraphitiService.client property returns stored client
   - Test GraphitiService.close() calls client.close() (mock the Graphiti client)
   - Test GraphitiService.create() factory method (mock Graphiti constructor and build_indices_and_constraints) -- verify it calls `build_indices_and_constraints()` and returns a GraphitiService instance
   - Use `unittest.mock.AsyncMock` and `unittest.mock.MagicMock` for mocking Graphiti
   - Mark async tests appropriately for pytest-asyncio

4. Create `tests/test_api/test_graph_status.py`:
   - Test the graph status endpoint using FastAPI TestClient or httpx AsyncClient
   - Mock `app.state.graph_service` with a mock GraphitiService
   - Test happy path: mock Neo4j session returning entity counts and last sync -> verify response shape
   - Test disconnected path: mock Neo4j session raising an exception -> verify `{"status": "disconnected", "error": "..."}`
   - Follow the pattern of existing test files in tests/test_api/ (check one for fixture patterns)

All tests should be unit tests (no external service dependencies). Use mocks for Neo4j driver and Graphiti client.
  </action>
  <verify>
- `pytest tests/test_graph/ -v` passes all tests
- `pytest tests/test_api/test_graph_status.py -v` passes
- `ruff check tests/test_graph/ tests/test_api/test_graph_status.py` passes
  </verify>
  <done>Test suite covers entity type taxonomy correctness (7 types, no protected fields), GraphitiService lifecycle (create/close), and graph status endpoint (connected/disconnected states).</done>
</task>

</tasks>

<verification>
- GraphitiService created in lifespan and closed on shutdown
- get_graph_service() in deps.py follows cast() pattern
- Neo4j status in /api/health endpoint
- GET /api/graph/status returns entity counts + last sync + status
- All new/modified code passes ruff check
- All tests pass: entity types, service lifecycle, graph status endpoint
</verification>

<success_criteria>
- `from pam.api.deps import get_graph_service` works
- Graph status endpoint is reachable at GET /api/graph/status
- /api/health now includes "neo4j" key in services response
- `pytest tests/test_graph/ tests/test_api/test_graph_status.py -v` all green
- Existing tests still pass (no regressions from lifespan changes)
</success_criteria>

<output>
After completion, create `.planning/phases/06-neo4j-graphiti-infrastructure/06-02-SUMMARY.md`
</output>
