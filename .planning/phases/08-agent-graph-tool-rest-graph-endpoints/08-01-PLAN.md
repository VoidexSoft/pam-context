---
phase: 08-agent-graph-tool-rest-graph-endpoints
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pam/graph/query.py
  - src/pam/agent/tools.py
  - src/pam/agent/agent.py
  - src/pam/api/deps.py
autonomous: true
requirements: [GRAPH-01, GRAPH-02, GRAPH-03, GRAPH-06]

must_haves:
  truths:
    - "Agent can answer relationship questions like 'what depends on X?' by calling search_knowledge_graph tool"
    - "Agent can answer temporal questions like 'how has X changed since Y?' by calling get_entity_history tool"
    - "Agent can query the graph at a specific point in time via reference_time parameter"
    - "Graph tool results never exceed 3000 characters or 20 nodes"
    - "Agent gracefully handles Neo4j being unavailable by returning a fallback message"
    - "Existing document search questions do not regress after adding graph tools"
  artifacts:
    - path: "src/pam/graph/query.py"
      provides: "Graph query functions for agent tools"
      contains: "search_graph_relationships"
    - path: "src/pam/agent/tools.py"
      provides: "Tool definitions including graph tools"
      contains: "SEARCH_KNOWLEDGE_GRAPH_TOOL"
    - path: "src/pam/agent/agent.py"
      provides: "Agent with graph_service integration and graph tool handlers"
      contains: "graph_service"
    - path: "src/pam/api/deps.py"
      provides: "Agent factory injecting graph_service"
      contains: "graph_service"
  key_links:
    - from: "src/pam/api/deps.py"
      to: "src/pam/agent/agent.py"
      via: "get_agent() passes graph_service to RetrievalAgent constructor"
      pattern: "graph_service=.*get_graph_service"
    - from: "src/pam/agent/agent.py"
      to: "src/pam/graph/query.py"
      via: "Tool handlers call query functions"
      pattern: "search_graph_relationships|get_entity_history"
    - from: "src/pam/agent/tools.py"
      to: "src/pam/agent/agent.py"
      via: "ALL_TOOLS includes graph tools, _execute_tool dispatches them"
      pattern: "search_knowledge_graph|get_entity_history"
---

<objective>
Add two knowledge graph tools to the Claude agent: `search_knowledge_graph` for relationship queries and `get_entity_history` for temporal queries. The agent will use Graphiti's `search()` for semantic relationship discovery and direct Cypher queries for precise temporal history, with graph_service injected through the existing dependency injection pattern.

Purpose: Enable natural language graph queries through the agent so users can ask "what depends on X?" and "how has X changed since Y?" and get cited answers from the knowledge graph.
Output: Working agent with 7 tools (5 existing + 2 graph), graph query module, updated dependency injection.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-CONTEXT.md
@.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-RESEARCH.md
@src/pam/agent/agent.py
@src/pam/agent/tools.py
@src/pam/api/deps.py
@src/pam/graph/service.py
@src/pam/graph/extraction.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create graph query module and add tool definitions</name>
  <files>
    src/pam/graph/query.py
    src/pam/agent/tools.py
  </files>
  <action>
**Create `src/pam/graph/query.py`** with two async functions:

1. `async def search_graph_relationships(graph_service, query: str, entity_name: str | None = None, relationship_type: str | None = None) -> str`:
   - Uses `graph_service.client.search(query=query, num_results=20)` for hybrid BM25+vector edge search
   - Formats each edge as: `"- {edge.fact} (relationship: {edge.name}, valid: {edge.valid_at}, invalidated: {edge.invalid_at or 'current'})"` -- per research Example 1
   - Filters edges by `entity_name` if provided (case-insensitive match on source/target node names)
   - Filters by `relationship_type` if provided (match on `edge.name`)
   - Caps results at 20 edges, then caps serialized text at 3000 characters with truncation message: `"... truncated. {total} total relationships found. Ask to narrow by type or relationship."` (GRAPH-06)
   - Wraps everything in try/except: on failure returns `"Graph database is currently unavailable. Try search_knowledge instead."` (per user decision: Neo4j down -> explain and fall back)
   - If no results found and entity_name given: `"No relationships found for '{entity_name}' in the knowledge graph. Searching documents may help."` (per user decision: entity not found -> auto-fallback hint)
   - Returns the formatted string (agent tool handlers return `tuple[str, list[Citation]]`, but query.py returns just the string; the agent handler wraps it)
   - Add structlog logging for the query and result count

2. `async def get_entity_history(graph_service, entity_name: str, since: str | None = None, reference_time: str | None = None) -> str`:
   - Uses direct Cypher via `graph_service.client.driver.session()` (NOT Graphiti search -- avoids embedding overhead for known entity names, per research Pitfall 3)
   - Cypher query pattern from research Example 2:
     ```cypher
     MATCH (n:Entity)-[e:RELATES_TO]-(m:Entity)
     WHERE n.name =~ $name_pattern
     AND ($since IS NULL OR e.created_at >= $since)
     RETURN e.fact AS fact, e.name AS rel_type,
            m.name AS related, labels(m) AS labels,
            e.valid_at AS valid_at, e.invalid_at AS invalid_at,
            e.created_at AS created_at
     ORDER BY e.created_at DESC
     LIMIT 20
     ```
   - Use `(?i){entity_name}` for case-insensitive matching (per research Open Question 1)
   - If `reference_time` is provided, add temporal WHERE clause: `AND e.valid_at <= $ref_time AND (e.invalid_at IS NULL OR e.invalid_at > $ref_time)` for point-in-time queries (GRAPH-03)
   - Format results with temporal status: `"- [{created_at}] {fact} ({status})"` where status is `"current"` or `"superseded {invalid_at}"`
   - Cap at 3000 chars with truncation (GRAPH-06)
   - Wrap in try/except: on failure return `"Graph database is currently unavailable."`
   - If no records: return `"No history found for entity '{entity_name}'."`
   - Filter out "Entity" from labels when displaying related entity types (per research Pitfall 5): `[l for l in labels if l != "Entity"]`
   - Add structlog logging

Import only what's needed: structlog, TYPE_CHECKING guard for GraphitiService. Use `from __future__ import annotations`.

**Update `src/pam/agent/tools.py`**:

Add two new tool definitions:

1. `SEARCH_KNOWLEDGE_GRAPH_TOOL` -- description MUST clearly differentiate from `search_knowledge`: "Search the knowledge graph for entity RELATIONSHIPS and connections. Use this for questions about what entities relate to, depend on, or interact with other entities. NOT for searching document text -- use search_knowledge for that."
   - Input schema: `query` (required string), `entity_name` (optional string -- specific entity to focus on), `relationship_type` (optional string -- filter by relationship type)
   - Make descriptions precise to avoid tool routing confusion with existing search_knowledge (per research Pitfall 4)

2. `GET_ENTITY_HISTORY_TOOL` -- description: "Get the temporal change history of a specific entity in the knowledge graph. Use this for questions about how an entity has CHANGED OVER TIME, when it was modified, or what it looked like at a specific date. Requires an entity name."
   - Input schema: `entity_name` (required string), `since` (optional string -- ISO datetime to filter changes after), `reference_time` (optional string -- ISO datetime for point-in-time snapshot)
   - Descriptions emphasize TEMPORAL nature to avoid overlap with search_knowledge_graph

Add both tools to `ALL_TOOLS` list after existing tools.
  </action>
  <verify>
    Run `python -c "from pam.graph.query import search_graph_relationships, get_entity_history; print('query module OK')"` and `python -c "from pam.agent.tools import ALL_TOOLS; assert len(ALL_TOOLS) == 7; print('7 tools OK')"` -- both should succeed.
    Run `ruff check src/pam/graph/query.py src/pam/agent/tools.py` -- no errors.
  </verify>
  <done>graph/query.py exists with search_graph_relationships and get_entity_history functions. tools.py has 7 tools total (5 existing + 2 graph). Both import cleanly with no errors.</done>
</task>

<task type="auto">
  <name>Task 2: Wire graph_service into agent and add tool dispatch handlers</name>
  <files>
    src/pam/agent/agent.py
    src/pam/api/deps.py
  </files>
  <action>
**Update `src/pam/api/deps.py`** -- inject `graph_service` into agent:

In `get_agent()`, add `graph_service` parameter:
```python
async def get_agent(
    request: Request,
    search_service: SearchService = Depends(get_search_service),
    embedder: OpenAIEmbedder = Depends(get_embedder),
    db: AsyncSession = Depends(get_db),
) -> RetrievalAgent:
    duckdb_service = get_duckdb_service(request)
    graph_service = getattr(request.app.state, "graph_service", None)  # Optional -- may be None if Neo4j unavailable
    return RetrievalAgent(
        search_service=search_service,
        embedder=embedder,
        api_key=cast(str, request.app.state.anthropic_api_key),
        model=cast(str, request.app.state.agent_model),
        cost_tracker=CostTracker(),
        db_session=db,
        duckdb_service=duckdb_service,
        graph_service=graph_service,
    )
```

Use `getattr` (not `Depends(get_graph_service)`) because graph_service is optional -- the agent should work even without Neo4j. The existing `get_graph_service` does a hard `cast()` which would fail if graph_service is None. This matches the pattern used for `duckdb_service` in the same function.

**Update `src/pam/agent/agent.py`**:

1. Add `graph_service` parameter to `RetrievalAgent.__init__`:
   ```python
   def __init__(
       self,
       search_service: SearchService,
       embedder: BaseEmbedder,
       api_key: str,
       model: str,
       cost_tracker: CostTracker | None = None,
       db_session: AsyncSession | None = None,
       duckdb_service: DuckDBService | None = None,
       graph_service: GraphitiService | None = None,
   ) -> None:
   ```
   Add `self.graph_service = graph_service` in the body.
   Add `GraphitiService` to the TYPE_CHECKING imports block.

2. Update `SYSTEM_PROMPT` to include graph tools in the tool list:
   ```
   Available tools:
   - search_knowledge: Search documents for relevant text segments.
   - get_document_context: Fetch full document content for deep reading.
   - get_change_history: See recent document changes and sync history.
   - query_database: Run SQL queries on analytics data files (CSV/Parquet/JSON).
   - search_entities: Search for structured business entities (metrics, events, KPIs).
   - search_knowledge_graph: Search the knowledge graph for entity relationships and connections.
   - get_entity_history: Get temporal change history of an entity in the knowledge graph.
   ```
   Also add rules for graph tool usage:
   ```
   8. Use search_knowledge_graph for questions about entity relationships, dependencies, and connections.
   9. Use get_entity_history for questions about how entities changed over time or point-in-time queries.
   10. You can combine document search and graph tools in one answer to give comprehensive results.
   ```

3. Update `_execute_tool` dispatch to add graph tool handlers:
   ```python
   if tool_name == "search_knowledge_graph":
       return await self._search_knowledge_graph(tool_input)
   if tool_name == "get_entity_history":
       return await self._get_entity_history(tool_input)
   ```

4. Add `_search_knowledge_graph` handler method:
   - Check `self.graph_service is None` -> return "Knowledge graph is not available. Try search_knowledge instead.", []
   - Import and call `search_graph_relationships` from `pam.graph.query`
   - Return `(result_text, [])` -- graph queries don't produce document citations directly (per research: source_description retrieval is deferred, not essential for Phase 8)

5. Add `_get_entity_history` handler method:
   - Check `self.graph_service is None` -> return "Knowledge graph is not available.", []
   - Import and call `get_entity_history` from `pam.graph.query`
   - Return `(result_text, [])`

Both handler methods are thin wrappers that check graph_service availability and delegate to query.py functions.

Import `from pam.graph.query import search_graph_relationships, get_entity_history` at the top of agent.py (alongside other imports from pam.*).
  </action>
  <verify>
    Run `python -c "from pam.api.deps import get_agent; print('deps OK')"` -- imports cleanly.
    Run `python -c "from pam.agent.agent import RetrievalAgent; print('agent OK')"` -- imports cleanly.
    Run `ruff check src/pam/agent/agent.py src/pam/api/deps.py` -- no errors.
    Run `grep -c 'graph_service' src/pam/agent/agent.py` -- should be >= 5 (init param, self assignment, 2 None checks in handlers, plus import).
    Run `grep 'search_knowledge_graph\|get_entity_history' src/pam/agent/agent.py | wc -l` -- should be >= 4 (2 dispatch + 2 handler defs).
  </verify>
  <done>Agent accepts graph_service in constructor. deps.py passes graph_service to agent (optional, via getattr). SYSTEM_PROMPT lists 7 tools with graph usage rules. _execute_tool dispatches to graph handlers. Both handlers delegate to query.py with None-safety for Neo4j unavailability.</done>
</task>

</tasks>

<verification>
1. `python -c "from pam.agent.tools import ALL_TOOLS; print(f'{len(ALL_TOOLS)} tools'); assert len(ALL_TOOLS) == 7"` -- 7 tools
2. `python -c "from pam.agent.agent import RetrievalAgent; import inspect; sig = inspect.signature(RetrievalAgent.__init__); assert 'graph_service' in sig.parameters; print('graph_service param OK')"` -- agent accepts graph_service
3. `python -c "from pam.graph.query import search_graph_relationships, get_entity_history; print('query module OK')"` -- query functions importable
4. `ruff check src/pam/agent/ src/pam/graph/query.py src/pam/api/deps.py` -- no lint errors
5. Verify SYSTEM_PROMPT contains "search_knowledge_graph" and "get_entity_history"
</verification>

<success_criteria>
- Agent has 7 tools total (5 existing + search_knowledge_graph + get_entity_history)
- graph_service flows from app.state through deps.py to RetrievalAgent
- Graph tools gracefully handle Neo4j being unavailable (return fallback message, not exception)
- Tool result text capped at 3000 chars / 20 nodes
- Tool descriptions clearly differentiate graph tools from document search tools
- No import errors, no lint errors
</success_criteria>

<output>
After completion, create `.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-01-SUMMARY.md`
</output>
