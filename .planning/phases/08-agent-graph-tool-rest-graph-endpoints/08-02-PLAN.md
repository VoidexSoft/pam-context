---
phase: 08-agent-graph-tool-rest-graph-endpoints
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pam/api/routes/graph.py
autonomous: true
requirements: [GRAPH-04, GRAPH-05, GRAPH-06]

must_haves:
  truths:
    - "GET /api/graph/neighborhood/{entity_name} returns a 1-hop subgraph with nodes and edges"
    - "GET /api/graph/entities returns paginated entity list with optional type filter"
    - "Neighborhood endpoint returns 404 for unknown entities"
    - "Neighborhood endpoint returns 503 when Neo4j is unavailable"
    - "Entities endpoint supports cursor-based pagination with opaque tokens"
    - "Node results never exceed 20 per response"
    - "REST error format matches existing PAM API patterns"
  artifacts:
    - path: "src/pam/api/routes/graph.py"
      provides: "Graph status + neighborhood + entities endpoints"
      contains: "graph_neighborhood"
  key_links:
    - from: "src/pam/api/routes/graph.py"
      to: "src/pam/graph/service.py"
      via: "Depends(get_graph_service) for Neo4j access"
      pattern: "Depends\\(get_graph_service\\)"
    - from: "src/pam/api/routes/graph.py"
      to: "Neo4j"
      via: "Direct Cypher queries via graph_service.client.driver.session()"
      pattern: "driver\\.session\\(\\)"
---

<objective>
Add two REST endpoints to the graph router: `GET /api/graph/neighborhood/{entity_name}` for 1-hop subgraph retrieval and `GET /api/graph/entities` for paginated entity listing with type filtering. These endpoints serve structured graph data for the Phase 9 Graph Explorer UI.

Purpose: Provide REST API access to graph data so the frontend can render neighborhoods and entity lists without going through the agent.
Output: Two new endpoints on the existing graph router with Pydantic response models and cursor pagination.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-CONTEXT.md
@.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-RESEARCH.md
@src/pam/api/routes/graph.py
@src/pam/api/pagination.py
@src/pam/graph/service.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Add neighborhood endpoint with 1-hop Cypher query</name>
  <files>
    src/pam/api/routes/graph.py
  </files>
  <action>
Add Pydantic response models and the neighborhood endpoint to the existing `graph.py` routes file.

**Add response models** (at top of file, after imports):

```python
from pydantic import BaseModel

class GraphNode(BaseModel):
    """A node in the graph response."""
    uuid: str
    name: str
    entity_type: str  # Label with "Entity" filtered out
    summary: str | None = None

class GraphEdge(BaseModel):
    """An edge in the graph response."""
    uuid: str
    source_name: str
    target_name: str
    relationship_type: str
    fact: str
    valid_at: str | None = None
    invalid_at: str | None = None

class NeighborhoodResponse(BaseModel):
    """1-hop neighborhood subgraph for an entity."""
    center: GraphNode
    nodes: list[GraphNode]
    edges: list[GraphEdge]
    total_edges: int  # Total before any limit
```

**Add `GET /api/graph/neighborhood/{entity_name}` endpoint:**

- Uses `Depends(get_graph_service)` for GraphitiService injection (existing pattern)
- Cypher query pattern (from research Example 3, adapted):
  ```cypher
  MATCH (n:Entity)
  WHERE n.name =~ $name_pattern
  WITH n LIMIT 1
  OPTIONAL MATCH (n)-[e:RELATES_TO]-(m:Entity)
  WHERE e.invalid_at IS NULL
  WITH n, e, m
  ORDER BY e.valid_at DESC
  LIMIT 20
  RETURN n.uuid AS center_uuid, n.name AS center_name, labels(n) AS center_labels, n.summary AS center_summary,
         collect(DISTINCT {uuid: e.uuid, fact: e.fact, name: e.name, valid_at: toString(e.valid_at), invalid_at: toString(e.invalid_at), source: startNode(e).name, target: endNode(e).name}) AS edges,
         collect(DISTINCT {uuid: m.uuid, name: m.name, labels: labels(m), summary: m.summary}) AS neighbors
  ```
  Actually, use a simpler approach since Neo4j Cypher `collect` with maps can be tricky. Do two queries or use `UNWIND`:

  **Better approach -- two simple queries:**
  1. Find center node: `MATCH (n:Entity) WHERE n.name =~ $name_pattern RETURN n LIMIT 1`
  2. Find 1-hop neighbors: `MATCH (n:Entity {uuid: $center_uuid})-[e:RELATES_TO]-(m:Entity) WHERE e.invalid_at IS NULL RETURN ...`

  But for performance, use a single query:
  ```cypher
  MATCH (n:Entity)
  WHERE n.name =~ $name_pattern
  WITH n LIMIT 1
  OPTIONAL MATCH (n)-[e:RELATES_TO]-(m:Entity)
  WHERE e.invalid_at IS NULL
  RETURN n.uuid AS n_uuid, n.name AS n_name, labels(n) AS n_labels, n.summary AS n_summary,
         e.uuid AS e_uuid, e.fact AS e_fact, e.name AS e_name,
         e.valid_at AS e_valid, e.invalid_at AS e_invalid,
         m.uuid AS m_uuid, m.name AS m_name, labels(m) AS m_labels, m.summary AS m_summary
  ORDER BY e.valid_at DESC
  LIMIT 21
  ```
  Use `(?i){entity_name}` for case-insensitive matching.

- Process records:
  - First record's `n_*` fields are the center node
  - Build unique nodes set from `m_*` fields (dedup by uuid)
  - Build edges list from `e_*` fields (dedup by uuid)
  - Filter "Entity" from labels: `[l for l in labels if l != "Entity"]`; take first remaining label as entity_type (per research Pitfall 5)
  - If no records or center is None: raise `HTTPException(status_code=404, detail=f"Entity '{entity_name}' not found")`
  - Cap at 20 edges (GRAPH-06)
  - Set `total_edges` to count before limiting (use LIMIT 21 to detect overflow)

- Error handling:
  - Wrap in try/except
  - Re-raise HTTPException (don't catch 404)
  - Other exceptions: raise `HTTPException(status_code=503, detail="Graph database unavailable")` (per user decision: REST error format matches existing PAM API patterns)

- Add `response_model=NeighborhoodResponse` to the decorator for OpenAPI visibility (per Phase 3 convention: all endpoints have response_model)
  </action>
  <verify>
    Run `python -c "from pam.api.routes.graph import router; routes = [r.path for r in router.routes]; assert '/graph/neighborhood/{entity_name}' in routes; print('neighborhood route OK')"` -- endpoint registered.
    Run `ruff check src/pam/api/routes/graph.py` -- no lint errors.
  </verify>
  <done>GET /api/graph/neighborhood/{entity_name} returns NeighborhoodResponse with center node, neighbor nodes, and edges. Returns 404 for unknown entities, 503 for Neo4j unavailable. Edges capped at 20.</done>
</task>

<task type="auto">
  <name>Task 2: Add entities listing endpoint with cursor pagination and type filter</name>
  <files>
    src/pam/api/routes/graph.py
  </files>
  <action>
**Add entity list response model:**

```python
class EntityListItem(BaseModel):
    """An entity in the listing."""
    uuid: str
    name: str
    entity_type: str
    summary: str | None = None

class EntityListResponse(BaseModel):
    """Paginated list of entities."""
    entities: list[EntityListItem]
    next_cursor: str | None = None
```

Note: Do NOT reuse PaginatedResponse from pagination.py -- it uses `items`/`total`/`cursor` fields designed for PG cursors. The graph entity list uses Neo4j UUID cursors with different semantics. The existing pagination.py `encode_cursor`/`decode_cursor` can be reused for encoding though.

**Add `GET /api/graph/entities` endpoint:**

- Query params: `entity_type: str | None = None`, `limit: int = 50`, `cursor: str | None = None`
- Uses `Depends(get_graph_service)`
- Decode cursor if provided: `decode_cursor(cursor)["id"]` to get last UUID (reuse existing pagination.py)
- Build Cypher dynamically:
  ```python
  cypher = "MATCH (n:Entity) "
  params = {"limit": min(limit, 50) + 1}  # +1 to detect next page, cap limit at 50

  where_parts = []
  if entity_type:
      # Validate entity_type is a known label to prevent Cypher injection
      # Use parameterized WHERE with label check
      where_parts.append(f"n:{entity_type}")  # Label match in Cypher is not parameterizable, but entity_type is validated
  if cursor_uuid:
      where_parts.append("n.uuid < $cursor_uuid")
      params["cursor_uuid"] = cursor_uuid

  if where_parts:
      cypher += "WHERE " + " AND ".join(where_parts) + " "

  cypher += "RETURN labels(n) AS labels, n.name AS name, n.uuid AS uuid, n.summary AS summary "
  cypher += "ORDER BY n.uuid DESC LIMIT $limit"
  ```

  **IMPORTANT on entity_type:** The `entity_type` query param is injected directly into the Cypher `n:Label` clause, which cannot be parameterized in Cypher. To prevent Cypher injection, validate that entity_type matches a known entity type from the taxonomy:
  ```python
  from pam.graph.entity_types import ENTITY_TYPES
  if entity_type and entity_type not in ENTITY_TYPES:
      raise HTTPException(status_code=400, detail=f"Unknown entity type: {entity_type}. Valid types: {', '.join(ENTITY_TYPES.keys())}")
  ```

- Process records:
  - Filter "Entity" from labels, take first remaining as entity_type
  - Build EntityListItem for each record
  - Detect next page: if `len(records) > limit`, there are more results
  - Build next_cursor using `encode_cursor(last_uuid, last_uuid)` from pagination.py (use uuid as both id and sort_value since we sort by uuid)
  - Slice items to `limit` (remove the +1 detection row)

- Error handling:
  - Wrap in try/except
  - Neo4j unavailable: raise `HTTPException(status_code=503, detail="Graph database unavailable")`

- Add `response_model=EntityListResponse` to the decorator

- Cap limit at 50 (no more than 50 entities per page) to prevent abuse
  </action>
  <verify>
    Run `python -c "from pam.api.routes.graph import router; routes = [r.path for r in router.routes]; assert '/graph/entities' in routes; print('entities route OK')"` -- endpoint registered.
    Run `ruff check src/pam/api/routes/graph.py` -- no lint errors.
    Verify entity_type validation: `grep 'ENTITY_TYPES' src/pam/api/routes/graph.py` should show the import and validation check.
  </verify>
  <done>GET /api/graph/entities returns EntityListResponse with paginated entity list. Supports ?entity_type= filter validated against known taxonomy. Supports cursor-based pagination with opaque tokens. Results capped at 50 per page. Returns 400 for unknown entity types, 503 for Neo4j unavailable.</done>
</task>

</tasks>

<verification>
1. `python -c "from pam.api.routes.graph import router; routes = [r.path for r in router.routes]; print(routes); assert '/graph/neighborhood/{entity_name}' in routes; assert '/graph/entities' in routes"` -- both routes registered
2. `python -c "from pam.api.routes.graph import GraphNode, GraphEdge, NeighborhoodResponse, EntityListItem, EntityListResponse; print('models OK')"` -- response models importable
3. `ruff check src/pam/api/routes/graph.py` -- no lint errors
4. `grep -c 'def graph_neighborhood\|def graph_entities' src/pam/api/routes/graph.py` -- should be 2
</verification>

<success_criteria>
- GET /api/graph/neighborhood/{entity_name} returns 1-hop subgraph (center + neighbors + edges)
- GET /api/graph/entities returns paginated entity list with optional type filter
- Neighborhood returns 404 for missing entities, 503 for Neo4j down
- Entities returns 400 for invalid type, 503 for Neo4j down
- Entity type filter validated against ENTITY_TYPES taxonomy (Cypher injection prevention)
- Cursor-based pagination with opaque base64 tokens
- Results capped at 20 nodes for neighborhood, 50 per page for entities list
- All response models have Pydantic BaseModel schemas for OpenAPI
</success_criteria>

<output>
After completion, create `.planning/phases/08-agent-graph-tool-rest-graph-endpoints/08-02-SUMMARY.md`
</output>
