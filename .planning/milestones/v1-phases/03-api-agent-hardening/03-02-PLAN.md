---
phase: 03-api-agent-hardening
plan: 02
type: execute
wave: 2
depends_on: ["03-01"]
files_modified:
  - src/pam/api/pagination.py
  - src/pam/api/routes/documents.py
  - src/pam/api/routes/admin.py
  - src/pam/api/routes/auth.py
  - src/pam/api/routes/ingest.py
  - src/pam/common/models.py
  - web/src/api/client.ts
autonomous: true

must_haves:
  truths:
    - "All list endpoints (documents, users, tasks) return cursor-paginated envelopes {items, total, cursor}"
    - "All document and admin endpoints have response_model visible in /docs OpenAPI schema"
    - "revoke_role returns 404 when the role assignment does not exist"
    - "get_me returns 501 Not Implemented when auth is disabled"
    - "get_segment uses a single JOIN query instead of 2 sequential queries"
    - "Frontend continues to function after pagination envelope changes (client.ts unwraps response.items)"
  artifacts:
    - path: "src/pam/api/pagination.py"
      provides: "Cursor encode/decode, PaginatedResponse schema, paginate helper"
      contains: "PaginatedResponse"
    - path: "src/pam/api/routes/documents.py"
      provides: "Paginated list_documents, JOIN-based get_segment, response_model on all endpoints"
      contains: "response_model"
    - path: "src/pam/api/routes/admin.py"
      provides: "Paginated list_users, revoke_role 404, response_model on all endpoints"
      contains: "response_model"
    - path: "web/src/api/client.ts"
      provides: "Frontend adapter unwrapping pagination envelope"
      contains: "items"
  key_links:
    - from: "src/pam/api/pagination.py"
      to: "src/pam/api/routes/documents.py"
      via: "import PaginatedResponse, encode_cursor, decode_cursor"
      pattern: "from.*pagination.*import"
    - from: "src/pam/api/pagination.py"
      to: "src/pam/api/routes/admin.py"
      via: "import PaginatedResponse, encode_cursor, decode_cursor"
      pattern: "from.*pagination.*import"
    - from: "web/src/api/client.ts"
      to: "src/pam/api/routes/documents.py"
      via: "HTTP fetch unwrapping items from pagination envelope"
      pattern: "response\\.items"
---

<objective>
Add cursor-based pagination to all list endpoints, add response_model to endpoints missing OpenAPI schemas, fix revoke_role to return 404 for non-existent roles, fix get_me to return 501 when auth is disabled, optimize get_segment with a JOIN query, and add minimal frontend adapter to unwrap the new pagination envelope.

Purpose: List endpoints currently return unbounded arrays with no pagination, several endpoints lack response_model (invisible in /docs), and edge-case behaviors (revoke_role silent 204, get_me 404) are incorrect. These fixes make the API production-ready with proper OpenAPI documentation and predictable behavior.

Output: New pagination.py module, updated route files with response_model and cursor pagination, response schema models in models.py, frontend client.ts adapter.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-api-agent-hardening/03-RESEARCH.md
@src/pam/api/routes/documents.py
@src/pam/api/routes/admin.py
@src/pam/api/routes/auth.py
@src/pam/api/routes/ingest.py
@src/pam/common/models.py
@web/src/api/client.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create pagination module, add response schemas, and add response_model to all endpoints</name>
  <files>
    src/pam/api/pagination.py
    src/pam/common/models.py
    src/pam/api/routes/documents.py
    src/pam/api/routes/admin.py
    src/pam/api/routes/auth.py
    src/pam/api/routes/ingest.py
  </files>
  <action>
    **Create `src/pam/api/pagination.py` (NEW file):**
    - `encode_cursor(last_id: str, sort_value: str) -> str`: JSON-encodes `{"id": last_id, "sv": sort_value}` with `sort_keys=True`, then `base64.urlsafe_b64encode`. Returns the base64 string.
    - `decode_cursor(cursor: str) -> dict`: `base64.urlsafe_b64decode` then `json.loads`. Returns dict with "id" and "sv" keys.
    - `PaginatedResponse(BaseModel, Generic[T])`: fields `items: list[T]`, `total: int`, `cursor: str` (empty string = no more pages). Use `TypeVar("T")` for generic.
    - Default page size constant: `DEFAULT_PAGE_SIZE = 50`

    **Add response Pydantic schemas to `src/pam/common/models.py`:**
    Create any missing response schemas needed for response_model. Check existing schemas first -- `DocumentResponse`, `SegmentResponse`, etc. may already exist. Only add what's missing:
    - `SegmentDetailResponse` (if not exists): for GET /segments/{id} -- includes segment fields + document title/source
    - `StatsResponse` (if not exists): for GET /stats -- document_count, segment_count, entity_counts (dict)
    - `RoleAssignedResponse` (if not exists): for POST /admin/roles -- user_id, project_id, role, message
    - `MessageResponse` (if not exists): for PATCH deactivate -- message field
    - `UserResponse` (if not exists): for admin list_users items

    **Add response_model to endpoints missing it (research Example 1):**

    `documents.py`:
    - `GET /documents`: `response_model=PaginatedResponse[DocumentResponse]` (will implement pagination in Task 2)
    - `GET /segments/{id}`: `response_model=SegmentDetailResponse`
    - `GET /stats`: `response_model=StatsResponse`

    `admin.py`:
    - `POST /admin/roles`: `response_model=RoleAssignedResponse`
    - `PATCH /admin/users/{id}/deactivate`: `response_model=MessageResponse`
    - `GET /admin/users`: `response_model=PaginatedResponse[UserResponse]` (will implement pagination in Task 2)

    `ingest.py`:
    - `GET /ingest/tasks` (if exists): `response_model=PaginatedResponse[IngestionTaskResponse]` (will implement pagination in Task 2)

    **Fix endpoint edge cases:**

    `auth.py` -- get_me returns 501 when auth disabled:
    - Change `raise HTTPException(status_code=404, detail="Auth not enabled")` to `raise HTTPException(status_code=501, detail="Authentication is not enabled")` (locked decision)

    `admin.py` -- revoke_role returns 404 when role doesn't exist:
    - After `await db.execute(delete(...))`, check `result.rowcount == 0` and raise `HTTPException(status_code=404, detail="Role assignment not found")`

    `documents.py` -- get_segment uses JOIN instead of 2 sequential queries:
    - Replace the 2 sequential queries with a single query using `selectinload(Segment.document)` or a JOIN
    - Access `segment.document` directly instead of a second query
    - Verify the Segment model has a `document` relationship defined; if not, add it to models.py

    `documents.py` -- get_stats partial failure:
    - Verify the existing try/except block already logs warning on entity query failure (research says it does). If it already logs with `exc_info=True`, no change needed (API-07 is already satisfied). If not, add `logger.warning("entity_count_query_failed", exc_info=True)`.
  </action>
  <verify>
    Run `python -c "from pam.api.pagination import PaginatedResponse, encode_cursor, decode_cursor, DEFAULT_PAGE_SIZE; print('OK')"` -- imports succeed.
    Run `python -m pytest tests/ -k "auth or admin or documents or stats or segment" -v` -- tests pass (some may need updates for new response shapes).
  </verify>
  <done>
    pagination.py exists with encode_cursor, decode_cursor, PaginatedResponse, DEFAULT_PAGE_SIZE. All endpoints have response_model. revoke_role returns 404 for non-existent roles. get_me returns 501 when auth disabled. get_segment uses a single JOIN query. Response schemas exist for all endpoints.
  </done>
</task>

<task type="auto">
  <name>Task 2: Implement cursor pagination on all list endpoints and add frontend adapter</name>
  <files>
    src/pam/api/routes/documents.py
    src/pam/api/routes/admin.py
    src/pam/api/routes/ingest.py
    web/src/api/client.ts
  </files>
  <action>
    **Cursor pagination on list endpoints:**

    For each list endpoint, apply the keyset pagination pattern from the research:
    1. Accept optional query params: `cursor: str = ""` and `limit: int = DEFAULT_PAGE_SIZE`
    2. Build base query with `ORDER BY sort_field DESC, id DESC` (tiebreaker on ID)
    3. If cursor is not empty, decode it and add keyset WHERE clause: `(sort_field < sv) | ((sort_field == sv) & (id < cursor_id))`
    4. Fetch `limit + 1` rows to detect next page
    5. Slice to `limit`, compute `has_next` from extra row
    6. Run `SELECT COUNT(*)` for total (tables are small, always include)
    7. Encode next cursor from last item if `has_next`, else empty string
    8. Return `PaginatedResponse(items=items, total=total, cursor=next_cursor)`

    **Endpoint-specific sort fields:**
    - `GET /documents`: sort by `Document.updated_at DESC`
    - `GET /admin/users`: sort by `User.created_at DESC` (or whatever the user table timestamp is)
    - `GET /ingest/tasks`: sort by `IngestionTask.created_at DESC`

    **Frontend adapter (`web/src/api/client.ts`):**
    Update the following functions to unwrap the pagination envelope so consuming hooks keep working without changes:
    - `listDocuments()`: was returning `Document[]`, now endpoint returns `{items, total, cursor}`. Update to `return response.items` (or equivalent). This is a minimal ~5-line change per function.
    - Any other list functions (`listUsers`, `listTasks`, etc.) -- apply same unwrapping pattern.
    - Add a `PaginatedResponse<T>` TypeScript interface: `{ items: T[], total: number, cursor: string }`
    - The hooks can adopt full pagination in Phase 4. For now, just unwrap items.

    **Update tests:**
    - Existing tests that call list endpoints expecting arrays will break. Update them to expect the `{items, total, cursor}` envelope.
    - Add test for cursor pagination: request page 1, use returned cursor for page 2, verify items don't overlap.
    - Add test for empty cursor on last page.
    - Add test for invalid cursor (should return 400 or ignore gracefully).
  </action>
  <verify>
    Run `python -m pytest tests/ -v` -- full test suite passes.
    Run `python -m pytest tests/ -k "pagina" -v` -- pagination-specific tests pass.
    Verify `web/src/api/client.ts` compiles: `cd web && npx tsc --noEmit 2>&1 | head -20` (no new type errors).
  </verify>
  <done>
    All three list endpoints (documents, users, tasks) return `{items: [...], total: N, cursor: "base64..."}`. Cursor is empty string when no more pages. Default page size is 50. Frontend client.ts unwraps `response.items` so hooks continue working. All tests pass including new pagination tests.
  </done>
</task>

</tasks>

<verification>
1. `python -m pytest tests/ -v` -- full test suite passes
2. OpenAPI schema check: start the app and verify `/docs` shows response_model for all document and admin endpoints
3. Pagination contract: `curl /documents?limit=2` returns `{items: [...], total: N, cursor: "..."}` with exactly 2 items
4. Pagination traversal: follow cursor to next page, no overlapping items
5. Edge cases: `revoke_role` for non-existent role returns 404; `get_me` with auth disabled returns 501
6. Frontend: `cd web && npx tsc --noEmit` passes
</verification>

<success_criteria>
- pagination.py module exists with PaginatedResponse, encode_cursor, decode_cursor
- All list endpoints return paginated envelopes with cursor-based navigation
- All document/admin endpoints have response_model in OpenAPI schema
- revoke_role returns 404 for non-existent roles
- get_me returns 501 when auth is disabled
- get_segment uses single JOIN query
- Frontend client.ts unwraps pagination envelope
- Full test suite passes
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-agent-hardening/03-02-SUMMARY.md`
</output>
