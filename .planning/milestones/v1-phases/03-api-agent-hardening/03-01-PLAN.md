---
phase: 03-api-agent-hardening
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - src/pam/api/middleware.py
  - src/pam/api/main.py
  - src/pam/agent/agent.py
  - src/pam/api/routes/chat.py
  - tests/unit/api/test_middleware.py
autonomous: true

must_haves:
  truths:
    - "SSE chat streaming delivers events immediately without buffering (BaseHTTPMiddleware removed)"
    - "When the LLM API fails mid-stream, the client receives a structured SSE error event with JSON payload {type, message} AND human-readable message"
    - "Non-first text chunks do not start with a leading space character"
  artifacts:
    - path: "src/pam/api/middleware.py"
      provides: "Pure ASGI middleware classes (CorrelationIdMiddleware, RequestLoggingMiddleware)"
      contains: "async def __call__(self, scope, receive, send)"
    - path: "src/pam/agent/agent.py"
      provides: "Fixed _chunk_text method and SSE error event format"
      contains: "_chunk_text"
  key_links:
    - from: "src/pam/api/middleware.py"
      to: "src/pam/api/main.py"
      via: "app.add_middleware() registration"
      pattern: "add_middleware.*(CorrelationId|RequestLogging)"
    - from: "src/pam/agent/agent.py"
      to: "src/pam/api/routes/chat.py"
      via: "answer_streaming() generator consumed by SSE endpoint"
      pattern: "answer_streaming"
---

<objective>
Replace BaseHTTPMiddleware with pure ASGI middleware to fix SSE streaming buffering, add structured SSE error events for LLM API failures, and fix the _chunk_text leading-space artifact.

Purpose: BaseHTTPMiddleware buffers the entire response body through call_next(), which holds SSE events until the stream completes. Pure ASGI middleware passes `send` through directly, enabling real-time SSE delivery. The SSE error events ensure clients get structured error information instead of silent drops when the LLM fails mid-stream.

Output: Rewritten middleware.py, enhanced streaming error handling in agent.py/chat.py, fixed _chunk_text.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-api-agent-hardening/03-RESEARCH.md
@src/pam/api/middleware.py
@src/pam/api/main.py
@src/pam/agent/agent.py
@src/pam/api/routes/chat.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Replace BaseHTTPMiddleware with pure ASGI middleware and add request timing</name>
  <files>
    src/pam/api/middleware.py
    src/pam/api/main.py
    tests/unit/api/test_middleware.py
  </files>
  <action>
    Rewrite `middleware.py` replacing both `CorrelationIdMiddleware` and `RequestLoggingMiddleware` with pure ASGI middleware classes.

    **CorrelationIdMiddleware (pure ASGI):**
    - `__init__(self, app)` stores the ASGI app
    - `__call__(self, scope, receive, send)` checks `scope["type"] != "http"` and passes through non-HTTP
    - Reads `x-correlation-id` from `scope["headers"]` (raw bytes list), falls back to `set_correlation_id(None)`
    - Defines inner `send_with_cid(message)` that appends `X-Correlation-ID` header via `MutableHeaders(scope=message)` when `message["type"] == "http.response.start"`
    - Calls `await self.app(scope, receive, send_with_cid)`
    - Import `MutableHeaders` from `starlette.datastructures`

    **RequestLoggingMiddleware (pure ASGI, with request timing):**
    - `__init__(self, app)` stores the ASGI app
    - `__call__(self, scope, receive, send)` checks `scope["type"] != "http"` and passes through non-HTTP
    - Records `start = time.perf_counter()` before calling inner app
    - Defines inner `send_with_status(message)` that captures `status_code` from `message["status"]` when `message["type"] == "http.response.start"`
    - After `await self.app(scope, receive, send_with_status)`, computes `latency_ms` and logs via `structlog.get_logger().info("http_request", method=..., path=..., status_code=..., latency_ms=round(latency_ms, 1))`
    - Import `time` at module top

    **Remove** all imports of `BaseHTTPMiddleware` from `starlette.middleware.base`.

    **main.py:** No changes needed to middleware registration calls -- `app.add_middleware()` works with both BaseHTTPMiddleware and pure ASGI classes. Verify the existing ordering is correct: CorrelationIdMiddleware added AFTER RequestLoggingMiddleware (so correlation ID wraps outermost).

    **Tests:** Update `tests/unit/api/test_middleware.py` if any tests directly import or mock BaseHTTPMiddleware internals (e.g., `dispatch` method). Replace with tests that exercise the ASGI `__call__` interface. Key test cases:
    - HTTP request gets correlation ID in response header
    - Non-HTTP scope (e.g., websocket) passes through without error
    - Request logging captures status code and latency_ms
    - Existing correlation ID from request header is preserved
  </action>
  <verify>
    Run `python -m pytest tests/unit/api/test_middleware.py -v` -- all tests pass.
    Run `grep -r "BaseHTTPMiddleware" src/pam/` -- returns no results.
    Run `python -c "from src.pam.api.middleware import CorrelationIdMiddleware, RequestLoggingMiddleware; print('OK')"` -- imports succeed.
  </verify>
  <done>
    Both middleware classes are pure ASGI (no BaseHTTPMiddleware inheritance). CorrelationIdMiddleware sets correlation ID on response headers. RequestLoggingMiddleware logs method, path, status_code, and latency_ms. Non-HTTP scopes pass through. All middleware tests pass.
  </done>
</task>

<task type="auto">
  <name>Task 2: Add structured SSE error events and fix _chunk_text leading space</name>
  <files>
    src/pam/agent/agent.py
    src/pam/api/routes/chat.py
  </files>
  <action>
    **SSE error events in agent.py (`answer_streaming`):**
    Find the `except` block in `answer_streaming()` that catches LLM API errors during streaming. Update it to yield a structured error event per the user's locked decision:
    ```python
    yield {
        "type": "error",
        "data": {"type": type(e).__name__, "message": str(e)},
        "message": f"An error occurred: {str(e)}"
    }
    ```
    - The `data` field contains the structured JSON payload (type + message)
    - The `message` field contains human-readable text
    - Do NOT send a `done` event after the error event (per research discretion recommendation -- frontend handles cleanup in `finally` block without needing `done` after error)
    - No retry logic -- fail fast, let user retry from UI (locked decision)

    **SSE error events in chat.py:**
    Verify that the SSE endpoint in `chat.py` correctly serializes the error event from `answer_streaming()` into SSE format. The `event: error` SSE event should carry the full payload. If chat.py constructs SSE events from the yielded dicts, ensure it handles the new `data` field. If it passes through the dict directly (via `sse-starlette` or similar), no changes needed -- just verify.

    **Fix _chunk_text leading space in agent.py:**
    Find the `_chunk_text` static method. Currently it prepends `" "` to non-first chunks:
    ```python
    # CURRENT (buggy): " " + chunk for i > 0
    ```
    Fix by appending a trailing space to all chunks EXCEPT the last one:
    ```python
    @staticmethod
    def _chunk_text(text: str, size: int = 4) -> list[str]:
        words = text.split(" ")
        chunks = []
        for i in range(0, len(words), size):
            chunk = " ".join(words[i : i + size])
            if i + size < len(words):
                chunk += " "  # trailing space as word separator
            chunks.append(chunk)
        return chunks
    ```
    The concatenation result is identical (`"Hello world " + "is great " + "today"` == `"Hello world " + " is great" + " today"`), but individual SSE token events no longer start with a leading space.

    **Tests:** Update any existing tests for `_chunk_text` to verify no leading spaces on non-first chunks. Add a test that `_chunk_text("hello world is great today", size=2)` produces `["hello world ", "is great ", "today"]`.
  </action>
  <verify>
    Run `python -m pytest tests/ -k "chunk_text or streaming or chat" -v` -- all tests pass.
    Run `python -c "from pam.agent.agent import RetrievalAgent; chunks = RetrievalAgent._chunk_text('hello world is great today', size=2); assert not chunks[1].startswith(' '), f'Leading space found: {chunks}'; print('OK:', chunks)"` -- no leading space.
  </verify>
  <done>
    SSE error events yield structured payload with {type, data: {type, message}, message} format. No done event follows error. _chunk_text produces trailing-space-separated chunks with no leading-space artifacts on non-first chunks. All existing and new tests pass.
  </done>
</task>

</tasks>

<verification>
1. `grep -r "BaseHTTPMiddleware" src/pam/` returns empty -- no BaseHTTPMiddleware usage remains
2. `python -m pytest tests/ -v` -- full test suite passes
3. Manual check: read middleware.py and confirm both classes use `async def __call__(self, scope, receive, send)` pattern
4. Manual check: read agent.py `answer_streaming` exception handler and confirm it yields structured error with `data` field
5. Manual check: read agent.py `_chunk_text` and confirm trailing-space pattern (not leading-space)
</verification>

<success_criteria>
- Zero BaseHTTPMiddleware usage in the codebase
- Both middleware classes are pure ASGI with scope type guards
- RequestLoggingMiddleware includes latency_ms in log output
- SSE error events contain both structured `data` and human-readable `message`
- _chunk_text chunks have no leading spaces (trailing spaces separate words between chunks)
- All tests pass including new middleware and chunk_text tests
</success_criteria>

<output>
After completion, create `.planning/phases/03-api-agent-hardening/03-01-SUMMARY.md`
</output>
