---
phase: 04-frontend-dead-code-cleanup
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - web/src/api/client.ts
  - web/src/api/client.test.ts
  - web/src/hooks/useChat.ts
  - web/src/components/ChatInterface.tsx
  - web/src/pages/ChatPage.tsx
  - web/src/hooks/useIngestionTask.ts
autonomous: true
requirements:
  - FE-01
  - FE-02
  - FE-03
  - FE-07
  - FE-09

must_haves:
  truths:
    - "Chat messages use stable unique keys (not array index), preventing unnecessary React remounts when new messages arrive"
    - "Chat auto-scrolls to bottom when user is at the bottom, but preserves scroll position when user has scrolled up to read history"
    - "SourceViewer Escape-key effect does not re-attach every parent render (onClose reference is stable via useCallback)"
    - "Ingestion task polling uses chained setTimeout with exponential backoff on errors, and cleans up on unmount with no leaked timers"
    - "GET requests do not send Content-Type: application/json header; POST/PUT/PATCH requests with body still do"
    - "Chat input, send/stop buttons, and new-conversation button have aria-label attributes"
  artifacts:
    - path: "web/src/api/client.ts"
      provides: "ChatMessage type with optional id field; request() only sets Content-Type when body present"
      contains: "id\\?: string"
    - path: "web/src/hooks/useChat.ts"
      provides: "Stable message ID generation via crypto.randomUUID()"
      contains: "crypto.randomUUID"
    - path: "web/src/components/ChatInterface.tsx"
      provides: "msg.id as React key, smart scroll behavior, aria-labels on input/buttons"
      contains: "key={msg.id"
    - path: "web/src/pages/ChatPage.tsx"
      provides: "useCallback-wrapped onClose handler, aria-label on new-conversation button"
      contains: "useCallback"
    - path: "web/src/hooks/useIngestionTask.ts"
      provides: "Chained setTimeout polling with exponential backoff"
      contains: "setTimeout"
    - path: "web/src/api/client.test.ts"
      provides: "Updated tests validating Content-Type present on POST, absent on GET"
  key_links:
    - from: "web/src/hooks/useChat.ts"
      to: "web/src/api/client.ts"
      via: "ChatMessage type with id field"
      pattern: "id: crypto\\.randomUUID\\(\\)"
    - from: "web/src/components/ChatInterface.tsx"
      to: "web/src/hooks/useChat.ts"
      via: "messages array with stable IDs used as React keys"
      pattern: "key=\\{msg\\.id"
    - from: "web/src/pages/ChatPage.tsx"
      to: "web/src/components/SourceViewer.tsx"
      via: "stable onClose callback reference preventing effect churn"
      pattern: "useCallback.*setViewingSegmentId"
---

<objective>
Fix React rendering inefficiencies in the chat system and ingestion polling, and correct HTTP header behavior in the API client.

Purpose: Eliminate unnecessary React remounts from array-index keys, prevent overlapping poll requests from setInterval, stop effect churn from unstable callback references, implement smart scroll (Slack/Discord pattern), and fix Content-Type header sent on bodyless GET requests.

Output: Six modified files with stable message keys, smart scroll, useCallback-wrapped onClose, chained setTimeout polling with exponential backoff, conditional Content-Type headers, and aria-labels on chat UI elements.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/04-frontend-dead-code-cleanup/04-RESEARCH.md

@web/src/api/client.ts
@web/src/api/client.test.ts
@web/src/hooks/useChat.ts
@web/src/hooks/useChat.test.ts
@web/src/components/ChatInterface.tsx
@web/src/pages/ChatPage.tsx
@web/src/hooks/useIngestionTask.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Stable message keys, smart scroll, useCallback onClose, and chat aria-labels</name>
  <files>
    web/src/api/client.ts
    web/src/hooks/useChat.ts
    web/src/components/ChatInterface.tsx
    web/src/pages/ChatPage.tsx
  </files>
  <action>
**1. Add `id` field to ChatMessage type** in `web/src/api/client.ts`:
- Add `id?: string` to the `ChatMessage` interface (optional for backward compatibility).

**2. Assign stable IDs at message creation** in `web/src/hooks/useChat.ts`:
- At every point where a new ChatMessage is created (user messages and assistant placeholder messages), add `id: crypto.randomUUID()`.
- User message creation: assign `id: crypto.randomUUID()` when building the user ChatMessage object.
- Assistant placeholder creation: assign `id: crypto.randomUUID()` when building the assistant ChatMessage object.

**3. Use stable key in ChatInterface.tsx**:
- Replace `key={i}` (or whatever array-index key is used) with `key={msg.id ?? i}` in the messages `.map()` call. The fallback to `i` is a safety net but should never trigger since all new messages get IDs.

**4. Implement smart scroll (Slack/Discord pattern)** in `web/src/components/ChatInterface.tsx`:
- Add a `scrollRef` (useRef<HTMLDivElement>) attached to the scrollable message container.
- Add an `isAtBottomRef` (useRef<boolean>) initialized to `true`.
- Add a `handleScroll` function on the scroll container's `onScroll` event that updates `isAtBottomRef.current` based on `scrollHeight - scrollTop - clientHeight <= 50` (50px threshold).
- Modify the existing auto-scroll `useEffect` (the one that calls `bottomRef.current?.scrollIntoView()`) to only scroll when `isAtBottomRef.current` is true.

**5. Wrap onClose in useCallback** in `web/src/pages/ChatPage.tsx`:
- Import `useCallback` from React (add to existing import if not present).
- Replace the inline `() => setViewingSegmentId(null)` with a `useCallback`-wrapped version:
  ```tsx
  const handleCloseViewer = useCallback(() => setViewingSegmentId(null), []);
  ```
- Pass `handleCloseViewer` to `<SourceViewer onClose={handleCloseViewer} />` instead of the inline arrow function.

**6. Add aria-labels to ChatInterface.tsx**:
- Message input textarea/input: add `aria-label="Type a message"`.
- Stop button: add `aria-label="Stop generating"`.
- Send button: add `aria-label="Send message"`.

**7. Add aria-label to ChatPage.tsx**:
- "New conversation" button: add `aria-label="Start new conversation"`.
  </action>
  <verify>
- Run `cd /Users/datnguyen/Projects/AI-Projects/pam-context/web && npx tsc --noEmit` -- no TypeScript errors.
- Run `cd /Users/datnguyen/Projects/AI-Projects/pam-context/web && npx vitest run` -- all existing tests pass.
- Grep for `key={i}` or `key={index}` in ChatInterface.tsx -- should NOT match (replaced with msg.id).
- Grep for `crypto.randomUUID` in useChat.ts -- should match at message creation points.
- Grep for `useCallback` in ChatPage.tsx -- should match.
- Grep for `aria-label` in ChatInterface.tsx -- should show 3+ matches (input, stop, send).
- Grep for `aria-label` in ChatPage.tsx -- should show 1+ match (new conversation).
- Grep for `isAtBottomRef` in ChatInterface.tsx -- should match (smart scroll).
  </verify>
  <done>
Chat messages render with stable unique keys (crypto.randomUUID). Smart scroll auto-follows at bottom, preserves position when scrolled up. SourceViewer onClose is a stable useCallback reference. Chat UI elements have aria-labels.
  </done>
</task>

<task type="auto">
  <name>Task 2: Chained setTimeout polling with backoff, and Content-Type fix</name>
  <files>
    web/src/hooks/useIngestionTask.ts
    web/src/api/client.ts
    web/src/api/client.test.ts
  </files>
  <action>
**1. Replace setInterval with chained setTimeout** in `web/src/hooks/useIngestionTask.ts`:
- Change the ref from `intervalRef` to `timeoutRef` (or rename accordingly).
- Add an `errorCountRef = useRef(0)` for tracking consecutive errors.
- Define constants: `BASE_INTERVAL = 1500` (preserves current behavior), `MAX_INTERVAL = 30000`.
- Replace the `setInterval(poll, POLL_INTERVAL)` call with initial `setTimeout(poll, BASE_INTERVAL)`.
- Inside the `poll` function:
  - On success: reset `errorCountRef.current = 0`, and if task is not terminal (completed/failed), schedule next poll via `timeoutRef.current = setTimeout(poll, BASE_INTERVAL)`.
  - On error (catch block): increment `errorCountRef.current`, compute backoff `Math.min(BASE_INTERVAL * Math.pow(2, errorCountRef.current), MAX_INTERVAL)`, schedule next poll with backoff delay.
  - On terminal status (completed/failed): do NOT schedule next poll. Set polling to false.
- Update the cleanup in the useEffect return: `clearTimeout(timeoutRef.current)` instead of `clearInterval`.
- Continue polling in background tabs (no visibility API needed -- browser naturally throttles).

**2. Fix Content-Type on GET requests** in `web/src/api/client.ts`:
- In the `request()` function, change the header construction so `Content-Type: application/json` is only set when `init?.body` is present.
- Current code unconditionally sets `"Content-Type": "application/json"` in the headers object. Change to conditionally include it:
  ```typescript
  const headers: Record<string, string> = {
    ...((init?.headers as Record<string, string>) || {}),
  };
  if (init?.body) {
    headers["Content-Type"] = headers["Content-Type"] || "application/json";
  }
  ```
- Do NOT change `streamChatMessage` -- it correctly sets Content-Type for its POST request.

**3. Update client.test.ts**:
- Find the test that asserts Content-Type is always present ("includes Content-Type by default" or similar). Update it to:
  - Test that POST requests with body include `Content-Type: application/json`.
  - Test that GET requests (no body) do NOT include `Content-Type` header.
- Keep any other existing tests unchanged.
  </action>
  <verify>
- Run `cd /Users/datnguyen/Projects/AI-Projects/pam-context/web && npx tsc --noEmit` -- no TypeScript errors.
- Run `cd /Users/datnguyen/Projects/AI-Projects/pam-context/web && npx vitest run` -- all tests pass (including updated client.test.ts).
- Grep for `setInterval` in useIngestionTask.ts -- should NOT match (replaced with setTimeout).
- Grep for `setTimeout` in useIngestionTask.ts -- should match.
- Grep for `errorCountRef` in useIngestionTask.ts -- should match (backoff tracking).
- Grep for `MAX_INTERVAL` in useIngestionTask.ts -- should match (30000).
- Grep for `init?.body` in client.ts request function -- should match (conditional Content-Type).
  </verify>
  <done>
Ingestion polling uses chained setTimeout: each poll schedules the next only after completion (no overlap). Exponential backoff (1.5s -> 3s -> 6s -> ... -> 30s max) on consecutive errors, reset to base on success. Cleanup on unmount via clearTimeout. GET requests no longer send Content-Type header; POST requests with body still do. Client tests updated to validate new behavior.
  </done>
</task>

</tasks>

<verification>
1. TypeScript compilation: `cd web && npx tsc --noEmit` passes with zero errors.
2. Frontend test suite: `cd web && npx vitest run` passes all tests (including updated client.test.ts).
3. No array-index keys: `grep -n 'key={i}' web/src/components/ChatInterface.tsx` returns nothing.
4. Stable IDs: `grep -n 'crypto.randomUUID' web/src/hooks/useChat.ts` returns matches.
5. Smart scroll: `grep -n 'isAtBottomRef' web/src/components/ChatInterface.tsx` returns matches.
6. Stable callback: `grep -n 'useCallback' web/src/pages/ChatPage.tsx` returns matches.
7. No setInterval: `grep -n 'setInterval' web/src/hooks/useIngestionTask.ts` returns nothing.
8. Backoff: `grep -n 'Math.pow' web/src/hooks/useIngestionTask.ts` returns matches.
9. Conditional Content-Type: `grep -n 'init?.body' web/src/api/client.ts` returns matches in request().
10. Aria-labels: `grep -rn 'aria-label' web/src/components/ChatInterface.tsx web/src/pages/ChatPage.tsx` returns 4+ matches total.
</verification>

<success_criteria>
- ChatMessage type has optional `id` field; all new messages get `crypto.randomUUID()` IDs.
- ChatInterface uses `msg.id` as React key (not array index).
- Smart scroll: auto-scrolls when at bottom, preserves position when scrolled up.
- ChatPage passes useCallback-wrapped `handleCloseViewer` to SourceViewer.
- useIngestionTask uses chained setTimeout with exponential backoff (base 1500ms, max 30000ms).
- client.ts request() only sets Content-Type when body is present.
- client.test.ts validates Content-Type on POST, absent on GET.
- Chat UI elements (input, send, stop, new conversation) have aria-labels.
- TypeScript compiles cleanly, all frontend tests pass.
</success_criteria>

<output>
After completion, create `.planning/phases/04-frontend-dead-code-cleanup/04-01-SUMMARY.md`
</output>
