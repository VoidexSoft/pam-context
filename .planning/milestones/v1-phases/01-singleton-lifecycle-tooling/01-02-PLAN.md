---
phase: 01-singleton-lifecycle-tooling
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - src/pam/api/main.py
  - src/pam/api/deps.py
  - src/pam/common/cache.py
  - src/pam/ingestion/task_manager.py
  - src/pam/api/routes/ingest.py
  - tests/test_api/conftest.py
  - tests/test_api/test_deps.py
autonomous: true

must_haves:
  truths:
    - "All service singletons are created in the FastAPI lifespan and stored on app.state"
    - "deps.py has zero module-level globals -- no _embedder, _reranker, _search_service, _duckdb variables or locks"
    - "deps.py dependency functions read exclusively from request.app.state"
    - "task_manager receives session_factory and cache_service as parameters, not via global imports"
    - "Redis client is created in lifespan and stored on app.state -- cache.py get_redis/close_redis globals removed"
    - "Running pytest -p randomly passes all 450+ tests with no order-dependent failures"
  artifacts:
    - path: "src/pam/api/main.py"
      provides: "Complete lifespan handler creating all singletons"
      contains: "app.state.embedder"
    - path: "src/pam/api/deps.py"
      provides: "Stateless dependency functions reading from app.state"
      exports: ["get_db", "get_es_client", "get_embedder", "get_search_service", "get_duckdb_service", "get_cache_service", "get_agent"]
    - path: "src/pam/ingestion/task_manager.py"
      provides: "Task manager with injected session_factory and cache_service"
    - path: "tests/test_api/conftest.py"
      provides: "Updated test fixtures for new deps.py signatures"
    - path: "tests/test_api/test_deps.py"
      provides: "Updated tests for stateless deps.py"
  key_links:
    - from: "src/pam/api/deps.py"
      to: "request.app.state"
      via: "all dependency functions read from app.state"
      pattern: "request\\.app\\.state\\."
    - from: "src/pam/api/main.py"
      to: "app.state assignments"
      via: "lifespan creates and stores all singletons"
      pattern: "app\\.state\\.(embedder|reranker|search_service|duckdb_service|session_factory|db_engine|cache_service)"
    - from: "src/pam/ingestion/task_manager.py"
      to: "session_factory parameter"
      via: "spawn_ingestion_task and run_ingestion_background accept session_factory"
      pattern: "session_factory"
    - from: "src/pam/api/routes/ingest.py"
      to: "src/pam/ingestion/task_manager.py"
      via: "passes session_factory from app.state to spawn_ingestion_task"
      pattern: "spawn_ingestion_task.*session_factory"
---

<objective>
Migrate all service singletons from deps.py module-level globals to FastAPI lifespan + app.state pattern, refactor task_manager to accept injected dependencies, and update all tests.

Purpose: Eliminates hidden shared state that causes test-order dependency and makes service lifecycle explicit and testable. This is the core architectural change of Phase 1.
Output: Stateless deps.py, complete lifespan handler, refactored task_manager, passing test suite.
</objective>

<execution_context>
@/Users/datnguyen/.claude/get-shit-done/workflows/execute-plan.md
@/Users/datnguyen/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-singleton-lifecycle-tooling/01-RESEARCH.md
@.planning/phases/01-singleton-lifecycle-tooling/01-01-SUMMARY.md

@src/pam/api/main.py
@src/pam/api/deps.py
@src/pam/common/cache.py
@src/pam/common/database.py
@src/pam/ingestion/task_manager.py
@src/pam/api/routes/ingest.py
@tests/test_api/conftest.py
@tests/test_api/test_deps.py
</context>

<tasks>

<task type="auto">
  <name>Task 1: Expand lifespan to create all singletons, clean deps.py, and refactor cache.py</name>
  <files>
    src/pam/api/main.py
    src/pam/api/deps.py
    src/pam/common/cache.py
  </files>
  <action>
**cache.py changes:**
Remove the module-level `_redis_client` global and `_redis_lock`. Remove the `get_redis()` and `close_redis()` functions. Keep `ping_redis()` but change it to accept a `client: redis.Redis | None` parameter instead of calling `get_redis()` internally. Keep the `_make_search_key` function and `CacheService` class (already refactored in Plan 01 to have required TTL params). Remove `from pam.common.config import settings` since CacheService no longer uses it (TTL params are now required) and `get_redis()` is being removed.

**main.py lifespan expansion:**
Expand the existing `lifespan` async context manager to create ALL singletons. Follow the pattern from the research (Example 1). The lifespan should:

1. Call `configure_logging(settings.log_level)` (already done).

2. **Database engine + session factory:**
   ```python
   from sqlalchemy.ext.asyncio import AsyncSession, async_sessionmaker, create_async_engine
   engine = create_async_engine(settings.database_url, echo=False, pool_size=5, max_overflow=10)
   session_factory = async_sessionmaker(engine, class_=AsyncSession, expire_on_commit=False)
   app.state.db_engine = engine
   app.state.session_factory = session_factory
   ```

3. **Elasticsearch client** (already done -- keep `app.state.es_client`).

4. **ES index** (already done via `ElasticsearchStore` -- but now pass `embedding_dims` to the constructor):
   ```python
   es_store = ElasticsearchStore(app.state.es_client, index_name=settings.elasticsearch_index, embedding_dims=settings.embedding_dims)
   ```

5. **Redis client** (replace `get_redis()` call):
   ```python
   import redis.asyncio as aioredis
   redis_client = None
   try:
       redis_client = aioredis.from_url(settings.redis_url, decode_responses=True)
       await redis_client.ping()
       logger.info("redis_connected", url=settings.redis_url)
   except Exception:
       logger.warning("redis_connect_failed", exc_info=True)
       redis_client = None
   app.state.redis_client = redis_client
   ```

6. **CacheService:**
   ```python
   cache_service = None
   if redis_client:
       cache_service = CacheService(redis_client, search_ttl=settings.redis_search_ttl, session_ttl=settings.redis_session_ttl)
   app.state.cache_service = cache_service
   ```

7. **Embedder:**
   ```python
   app.state.embedder = OpenAIEmbedder(
       api_key=settings.openai_api_key,
       model=settings.embedding_model,
       dims=settings.embedding_dims,
   )
   ```

8. **Reranker (conditional):**
   ```python
   reranker = None
   if settings.rerank_enabled:
       from pam.retrieval.rerankers.cross_encoder import CrossEncoderReranker
       reranker = CrossEncoderReranker(model_name=settings.rerank_model)
   app.state.reranker = reranker
   ```

9. **Search service (haystack or legacy):**
   ```python
   if settings.use_haystack_retrieval:
       from pam.retrieval.haystack_search import HaystackSearchService
       app.state.search_service = HaystackSearchService(
           es_url=settings.elasticsearch_url,
           index_name=settings.elasticsearch_index,
           cache=cache_service,
           rerank_enabled=settings.rerank_enabled,
           rerank_model=settings.rerank_model,
       )
   else:
       app.state.search_service = HybridSearchService(
           app.state.es_client,
           index_name=settings.elasticsearch_index,
           cache=cache_service,
           reranker=reranker,
       )
   ```

10. **DuckDB (conditional):**
    ```python
    duckdb_service = None
    if settings.duckdb_data_dir:
        from pam.agent.duckdb_service import DuckDBService
        duckdb_service = DuckDBService(
            data_dir=settings.duckdb_data_dir,
            max_rows=settings.duckdb_max_rows,
        )
        duckdb_service.register_files()
    app.state.duckdb_service = duckdb_service
    ```

11. **Stale task recovery** (update to use `session_factory` instead of `async_session_factory` proxy):
    ```python
    async with session_factory() as session:
        await session.execute(
            sa_update(IngestionTask)
            .where(IngestionTask.status.in_(["pending", "running"]))
            .values(status="failed", error="Server restarted", completed_at=func.now())
        )
        await session.commit()
    ```

12. **Shutdown:**
    ```python
    yield
    if redis_client:
        await redis_client.aclose()
    await app.state.es_client.close()
    await engine.dispose()
    ```

Remove imports that are no longer needed: `from pam.common.cache import close_redis, get_redis, ping_redis` (replace `ping_redis` usage in health check with `app.state.redis_client` direct ping). Remove `from pam.common.database import async_session_factory`.

Update the health endpoint to use `app.state.redis_client` for Redis health check instead of calling `ping_redis()`. Access it via the Request object:
```python
@app.get("/api/health")
async def health(request: Request, ...):
    # Redis check
    redis_client = getattr(request.app.state, "redis_client", None)
    if redis_client:
        try:
            if await redis_client.ping():
                services["redis"] = "up"
            else:
                services["redis"] = "down"
        except Exception:
            services["redis"] = "down"
    else:
        services["redis"] = "down"
```

**deps.py rewrite:**
Remove ALL module-level globals: `_embedder`, `_embedder_lock`, `_reranker`, `_reranker_initialized`, `_reranker_lock`, `_search_service`, `_search_service_lock`, `_duckdb_service`, `_duckdb_initialized`, `_duckdb_lock`.

Remove imports: `asyncio`, `Any`, `from pam.common.config import settings`, `from pam.common.database import async_session_factory`.

Rewrite all dependency functions to read from `request.app.state`:

```python
async def get_db(request: Request) -> AsyncGenerator[AsyncSession, None]:
    session_factory = request.app.state.session_factory
    async with session_factory() as session:
        try:
            yield session
        except Exception:
            await session.rollback()
            raise

def get_es_client(request: Request) -> AsyncElasticsearch:
    return request.app.state.es_client

def get_embedder(request: Request) -> OpenAIEmbedder:
    return request.app.state.embedder

def get_search_service(request: Request) -> HybridSearchService:
    return request.app.state.search_service

def get_reranker(request: Request) -> BaseReranker | None:
    return request.app.state.reranker

def get_duckdb_service(request: Request) -> DuckDBService | None:
    return request.app.state.duckdb_service

def get_cache_service(request: Request) -> CacheService | None:
    return request.app.state.cache_service

async def get_agent(
    request: Request,
    search_service: HybridSearchService = Depends(get_search_service),
    embedder: OpenAIEmbedder = Depends(get_embedder),
    db: AsyncSession = Depends(get_db),
) -> RetrievalAgent:
    duckdb_service = get_duckdb_service(request)
    return RetrievalAgent(
        search_service=search_service,
        embedder=embedder,
        cost_tracker=CostTracker(),
        db_session=db,
        duckdb_service=duckdb_service,
    )
```

Note: `get_embedder`, `get_search_service`, `get_reranker`, `get_duckdb_service`, `get_cache_service` are now synchronous (no async needed -- just attribute access). `get_db` remains async (generator). `get_agent` remains async.

Add the `DuckDBService` import at the top (it's now used in the type hint for `get_duckdb_service`). Use `from __future__ import annotations` (already present) so this doesn't force an eager import:
```python
from pam.agent.duckdb_service import DuckDBService
```
If this causes circular import issues, use `TYPE_CHECKING` guard instead.

**Important:** The `get_cache_service` function currently creates a new CacheService on each call. After this refactor it should read from `app.state.cache_service` (created once in lifespan). This is correct because CacheService is stateless beyond its config.

Existing `dependency_overrides` in tests use `lambda: mock_obj` pattern. Since the new dep functions take `Request` as first param, but `dependency_overrides` replaces the entire function, the existing `lambda: mock` pattern continues to work -- FastAPI calls the override function directly, not the original.
  </action>
  <verify>
Run `ruff check src/pam/api/main.py src/pam/api/deps.py src/pam/common/cache.py` -- zero violations.
Run `mypy src/pam/` -- zero errors.
Run `grep -n "_embedder\|_reranker\|_search_service\|_duckdb" src/pam/api/deps.py` -- no module-level globals found.
Run `grep -n "get_redis\|close_redis\|_redis_client\|_redis_lock" src/pam/common/cache.py` -- no module-level globals found.
Run `pytest tests/ -x -q` -- all tests pass.
  </verify>
  <done>
Lifespan creates all singletons (DB engine, session_factory, ES client, Redis, CacheService, embedder, reranker, search_service, duckdb_service) on app.state. deps.py has zero module-level globals and reads exclusively from request.app.state. cache.py module-level Redis globals removed.
  </done>
</task>

<task type="auto">
  <name>Task 2: Refactor task_manager to accept injected dependencies and update tests</name>
  <files>
    src/pam/ingestion/task_manager.py
    src/pam/api/routes/ingest.py
    tests/test_api/conftest.py
    tests/test_api/test_deps.py
  </files>
  <action>
**task_manager.py refactoring:**
Remove `from pam.common.database import async_session_factory` and `from pam.common.cache import CacheService, get_redis`.

Add `session_factory` as a required parameter to `spawn_ingestion_task` and `run_ingestion_background`. Add `cache_service: CacheService | None = None` as an optional parameter to both (for cache invalidation after ingestion).

Update `spawn_ingestion_task` signature:
```python
def spawn_ingestion_task(
    task_id: uuid.UUID,
    folder_path: str,
    es_client: AsyncElasticsearch,
    embedder: BaseEmbedder,
    session_factory,  # async_sessionmaker
    cache_service: CacheService | None = None,
) -> None:
```

Update `run_ingestion_background` signature similarly. Replace all `async with async_session_factory() as session:` calls inside with `async with session_factory() as session:`.

Replace the cache invalidation block (currently imports `get_redis` and creates a new `CacheService`):
```python
# OLD:
redis_client = await get_redis()
cache = CacheService(redis_client)
cleared = await cache.invalidate_search()

# NEW:
if cache_service:
    cleared = await cache_service.invalidate_search()
    logger.info("cache_invalidated_after_ingest", keys_cleared=cleared)
```

Update `recover_stale_tasks` to accept `session_factory` as a parameter:
```python
async def recover_stale_tasks(session_factory) -> int:
    async with session_factory() as session:
        ...
```

Add proper type hint import for session_factory: `from sqlalchemy.ext.asyncio import async_sessionmaker` and type the parameter as `async_sessionmaker`.

Keep the `from pam.common.cache import CacheService` import (used for type hint of cache_service parameter). Remove `from pam.common.cache import get_redis`.

**ingest.py route updates:**
Update `ingest_folder` to pass `session_factory` and `cache_service` to `spawn_ingestion_task`. Add a new dependency function or access `request.app.state` directly. The cleanest approach: add `request: Request` parameter to the route and read from `request.app.state`:

```python
from fastapi import APIRouter, Depends, HTTPException, Query, Request

@router.post("/ingest/folder", ...)
async def ingest_folder(
    request: Request,
    body: IngestFolderRequest,  # rename from 'request' to 'body' to avoid shadowing
    db: AsyncSession = Depends(get_db),
    es_client: AsyncElasticsearch = Depends(get_es_client),
    embedder: OpenAIEmbedder = Depends(get_embedder),
    _admin: User | None = Depends(require_admin),
):
    ...
    spawn_ingestion_task(
        task.id,
        body.path,
        es_client,
        embedder,
        session_factory=request.app.state.session_factory,
        cache_service=request.app.state.cache_service,
    )
```

Note: The route parameter was named `request: IngestFolderRequest` which shadows `Request`. Rename it to `body` to avoid the collision.

**Also update main.py** stale task recovery to use the new `recover_stale_tasks(session_factory)` signature if `recover_stale_tasks` is called there. Currently the stale task recovery is inline SQL in main.py -- if that stays inline, no change needed. If it calls `recover_stale_tasks`, pass `session_factory`.

**tests/test_api/conftest.py updates:**
The existing overrides use `lambda: mock_obj`. After the deps.py refactor, `get_db` now takes `Request` and is a generator. The override pattern `lambda: mock_db_session` still works because FastAPI replaces the entire dependency function with the override. No changes needed to the `lambda: mock` pattern.

However, verify that all imported dependency functions match the new module. If any test imports like `from pam.api.deps import get_duckdb_service` were previously missing, add them. Currently `conftest.py` imports: `get_agent, get_db, get_embedder, get_es_client, get_search_service`. Add overrides for `get_cache_service` and `get_duckdb_service` if routes use them.

**tests/test_api/test_deps.py updates:**
The existing `TestGetDuckdbService` class directly accesses `deps_module._duckdb_service` and `deps_module._duckdb_initialized` module globals -- these no longer exist. Rewrite the tests:

Since `get_duckdb_service` is now just `return request.app.state.duckdb_service`, testing it means testing that it reads from app.state. The test should:
1. Create a mock Request with mock app.state containing a duckdb_service value
2. Call `get_duckdb_service(request)` and verify it returns the value from app.state
3. Test with `None` to verify it returns None when not configured

This is much simpler than the old tests. The singleton lifecycle is now tested by testing the lifespan handler, which is implicitly tested by integration tests.

```python
from unittest.mock import MagicMock
from pam.api.deps import get_duckdb_service, get_embedder, get_search_service

class TestStatelessDeps:
    def test_get_duckdb_service_returns_from_app_state(self):
        mock_service = MagicMock()
        request = MagicMock()
        request.app.state.duckdb_service = mock_service
        assert get_duckdb_service(request) is mock_service

    def test_get_duckdb_service_returns_none_when_not_set(self):
        request = MagicMock()
        request.app.state.duckdb_service = None
        assert get_duckdb_service(request) is None

    def test_get_embedder_returns_from_app_state(self):
        mock_embedder = MagicMock()
        request = MagicMock()
        request.app.state.embedder = mock_embedder
        assert get_embedder(request) is mock_embedder

    def test_get_search_service_returns_from_app_state(self):
        mock_search = MagicMock()
        request = MagicMock()
        request.app.state.search_service = mock_search
        assert get_search_service(request) is mock_search
```

**Run pytest -p randomly after all changes** to verify no order-dependent failures:
```bash
pytest tests/ -p randomly --randomly-seed=12345 -x -q
```

Try 2-3 different seeds to increase confidence.
  </action>
  <verify>
Run `ruff check src/ tests/` -- zero violations.
Run `mypy src/pam/` -- zero errors.
Run `pytest tests/ -x -q` -- all tests pass.
Run `pytest tests/ -p randomly --randomly-seed=12345 -x -q` -- all tests pass with random order.
Run `pytest tests/ -p randomly --randomly-seed=67890 -x -q` -- all tests pass with different random order.
Run `grep -rn "async_session_factory\|get_redis\b" src/pam/ingestion/task_manager.py` -- no global imports remain.
Run `grep -rn "_embedder\|_reranker\|_search_service\|_duckdb_service\|_redis_client" src/pam/api/deps.py src/pam/common/cache.py` -- no module-level globals found.
  </verify>
  <done>
task_manager.py accepts session_factory and cache_service as parameters with no global imports. ingest.py route passes dependencies from app.state. deps.py is fully stateless. All tests pass including with randomized order (pytest-randomly). No module-level singleton state remains anywhere in deps.py or cache.py.
  </done>
</task>

</tasks>

<verification>
1. `grep -rn "^_embedder\|^_reranker\|^_search_service\|^_duckdb\|^_redis_client\|^_redis_lock" src/pam/api/deps.py src/pam/common/cache.py` -- zero matches (all module-level globals removed)
2. `grep -c "request.app.state" src/pam/api/deps.py` -- at least 7 occurrences (one per dependency function)
3. `grep -c "app.state" src/pam/api/main.py` -- at least 10 occurrences (all singletons stored)
4. `grep -rn "from pam.common.database import async_session_factory" src/pam/ingestion/task_manager.py` -- zero matches
5. `grep -rn "from pam.common.cache import.*get_redis" src/pam/ingestion/task_manager.py src/pam/api/main.py` -- zero matches
6. `pytest tests/ -x -q` -- all tests pass
7. `pytest tests/ -p randomly -x -q` -- all tests pass with randomized order
8. `ruff check src/ tests/` -- zero violations
9. `mypy src/pam/` -- zero errors
</verification>

<success_criteria>
- deps.py contains ZERO module-level mutable state (no globals, no locks)
- All deps.py functions read from request.app.state
- main.py lifespan creates all 9 singletons: db_engine, session_factory, es_client, redis_client, cache_service, embedder, reranker, search_service, duckdb_service
- task_manager.py receives session_factory and cache_service as parameters
- cache.py has no module-level Redis client globals
- All 450+ tests pass, including with random test ordering
- Ruff and mypy continue to pass
</success_criteria>

<output>
After completion, create `.planning/phases/01-singleton-lifecycle-tooling/01-02-SUMMARY.md`
</output>
